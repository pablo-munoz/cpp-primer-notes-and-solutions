#+TITLE: C++ Primer Notes
* Introduction
This document contains a collection of notes that I took while reading
C++ Primer, 5th edition by Stanly B. Lippman, Josée Lajoie and Barbara
E. Moo. Accompanying this notes are a number of directories (one for
almost every chapter) that include my solutions to some of the
exercises encountered in the book.

* READLOG
[2017-12-01 Fri 23:17]

| Date             | Page |
|------------------+------|
| <2017-12-29 Fri> |  366 |
| <2017-12-31 Sun> |  468 |
| <2018-01-01 Mon> |  506 |
| <2018-01-02 Tue> |  527 |
| <2018-01-03 Wed> |  531 |
| <2018-01-04 Thu> |  562 |
| <2018-01-05 Fri> |  608 |
| <2018-01-06 Sat> |  629 |
| <2018-01-08 Mon> |  645 |
| <2018-01-14 Sun> |  682 |
| <2018-01-15 Mon> |  694 |
| <2018-01-16 Tue> |  711 |
| <2018-01-18 Thu> |  717 |
| <2018-01-19 Fri> |  752 |
| <2018-01-20 Sat> |  762 |
| <2018-01-20 Sat> |  784 |

* Chapter 02: Variables and Base Types
[2017-12-05 Tue 13:03]

A declaration only makes the name known. A definition also sets the
associated entity. To do a declaration that is not a definition, use
the =extern= keyword.

A scope is a part of the program in which a name has a particular
meaning. Scopes can be nested. Inner scopes can redefine identifiers
in the outer scopes.

Funny thing, it seems that in c++, to store the address of a thing,
you use the ampersand symbol in the name that we want to store the
address in, not in the object that we want the address of.

#+BEGIN_EXAMPLE
int ival = 1024;
int &refval = ival;
#+END_EXAMPLE

Amazingly enough, to get the object out of the reference we can drop
the address of operator, I tried two ways, one by prepending * to the
reference and one without the ampersand, they both yielded the same
results.

#+BEGIN_EXAMPLE
std::cout << "*&refval: " << *&refval << std::endl;
std::cout << "refval: " << refval << std::endl;
#+END_EXAMPLE

The two statements above print the same output.

It is recommended ot use nullptr (added in the c++11 standard), not
NULL or 0.

* Chapter 03: Strings, Vectors and Arrays
[2017-12-15 Fri 21:20]

I had previously seen that you could do class initialization
by simply putting the arguments to the constructor in parenthesis
after the type and name declaration i.e.

#+BEGIN_SRC cpp
std::string str("some string");
#+END_SRC

I now know that is referred to as "direct initialization". What I
didn't know is that it is equivalent to a statement like.

#+BEGIN_SRC cpp
std::string str = "some string"
#+END_SRC

This is known as "copy initialize".

However, this equivalence only holds when the constructors are used
with only one argument. Should we want to initialize a variable using
a constructor that takes more than one argument, we would have to use
the direct initialization.

C libraries are accesible both through their ".h" files or, the name
of the files without the ".h" and preceded by a "c", i.e., "ctype.h"
can be accessed as "cctype". The difference is that with the latter
syntax, the objects in the library are exported as part of the =std::=
namespace.

The book first mentioned templates on the chapter on vectors. It
states (as I correctly assumed) that templates are instructions to the
compiler for generating classes for us, what I did not know is that
there are also function templates.

An important emphasis is put into saying that =vector= is a template,
not a type, types generated from a =vector= must include the element
type, i.e.  =vector<int>= is a type.

I've been reading up on iterators and its all good. However, the
following question occurred to me: ¿When using =auto= to get the type
of the iterator, how can we get it to be const, and not have to write
=container<type>::const_iterator=? The answer is that if the container
is const, =begin()= and =end()= will return a const iterator, but if
the container is not const, it will return a regular
iterator. However, there are =cbegin()= and =cend()= methods that
return the corresponding const iterator.

We could do our own calculations to get the =beginp= and =endp=
pointers to elements of an array, however the library gives us
fucntion =begin= and =end= for this purpose, this functions take an
array and return a pointer to the first element, and one past the last
element, respectively.

The c++ =std::string= has a =c_str()= method that returns a c-style
string.

To use a multidimensional array in a range for, the loop control
variable for all but the innermost array must be references.

* Chapter 04: Expressions
[2017-12-22 Fri 22:37]

Apparently, what I understood as casts, e.g. =(int) something=, is an
old-style cast. Nowadays casts have a name and you write what you want
the value to get casted to under brackets, e.g. =static_cast<int>
(a_long)=.

* Chapter 06: Functions
[2017-12-28 Thu 00:37]

The =static= modifier makes it so that variables in functions don't
get destroyed after the scope exits, but rather, when the program
terminates.  This makes it possible to have variables that survive
function calls and do things like count the number of times a
function has been called.

In C, programmers often use pointer parameters to access objects
outside a function. In C++ programmers generally use reference
parameters for that purpose.

We cannot pass an array by value, we will always be passing a pointer
to its first element. You could even put the size of an array that is
a parameter in a function declaration, but it would serve for
informative purposes only and wouldn't be enforced.

Techniques used to deal with passing arrays:

- If the data is suitable, use an end of data marker, like the null
  character for char arrays or old-style string literals.
- Pass a pointer to the beginning and the end of the array.
- Explicitly passing a size parameter.



For variadic function where all of the parameters are of the same
time, we can make the declaration of a function use
=initializer_list<T>=, keep in mind that when calling, the variadic
number of arguments must be given inside curly braces. Just like if we
were initializing an array automatically out of a given number of
elements.

Return types can be references too.

Never Return a Reference or Pointer to a Local Object since after the
function has exited, its resources are freed.

If the return type of a function is a refrence, it is an lvalue, and we could
have a function call on the left sign of an assignment. Think of a function
that takes a string and a index and returns a character by reference,
we could then do something like =get_val(s, 3) = 'A'=

We can also return a list of stuff in curly brackets if the return
type accepts copy initialization (also works with =std::pair=) like
that.

The c++ adds the possiblity to have trailing return types, that is
return types that appear on the right hand side of a function declaration
by using the following sytnax:

#+BEGIN_EXAMPLE
auto func(int i) -> int(*)[10];
#+END_EXAMPLE

A constexpr function is permitted to return a value that is not a
constant.

A function's name is not part of its type, and therefore is not
included when making pointers to functions.

Just like with arrays, we cannot define parameters of function type
but can have parameter that is a pointer to a function. It is a good
idea to use decltype to create pointers to function as tha treally
simplifies stuf.

Use pass by reference to const for class types other than iterators,
initializer_lists or functional objects; use pass by value otherwise.

Functions are named units of computation.
* Chapter 07: Classes
[2017-12-29 Fri 16:24]

During chapter 7, I wrote methods for a "class" called Sales_data,
however, in its header file, Sales_data was actually implemented as a
struct, which led me to ask what might be the difference between using
a struct and using a class. In my research, I found that the only
seeming difference is that a struct has its members public by default,
whereas a class has its members private by default. The struct is
still used in c++ because it is desired to be able to use structs that
where originally designed for the c language (backwards
compatibility).

If we do not provide a default constructor, the compiler will provide
one for us, this is what is called a synthesized default constructor,
and it will first attempt to use some default initializer (or default
values) that we have for members in the class definitions, if not
found, will default initialize those members just like it would be
with a non-member variable. The default constructor is done for us
only if we do not define any other constructors, it is not sufficient
to lack the 0 parameter constructor.

Once we add some constructor, the synthesized default constructor is
no longer given to us, if we intend to still use the default
constructor in the same way that its sinthesized version worked, we
probably don't want to go through the trouble of coding what was
already done automatically for us, therefore we can use

#+BEGIN_EXAMPLE
Class_name() = default
#+END_EXAMPLE

to indicate that we would like to keep the synthesized one.

A class can allow another class or function to access its nonpublic
members by making that class or function a friend. A class makes a
function its friend by including a declaration for that function
preceded by the keyword friend;

We can use the =mutable= keyword to denote that a class member is to
be modifyable even inside of const functions.

If a friend function is defined inside a class body it will be
implicitly inline.

You can decide against making a class a friend, and only some of its
methods, but then, if those methods are overloaded, you'd need to
declare friendship with each overloaded prototype.

If you use the scope operator =::= alone, you can get access to the
outer scope. I read this on a part of the book that was talking about
how variable resolution is done inside class methods, first the
parameters are considered, if the parameter have the same name as some
member, you can still access the member with =this->member_name=,
similar thing for globals, by doing =::variable_name= in case a
parameter or a member is obscuring it.

We must use the constructor initializer list to provide values for
members that are const, reference, or of a class type that does not
have a default constructor.

Members are intialized in the order that they appear in the class
definition, not in the order given in a constructor initializer.

You can write a constructor that delegates to another constructor by
invoking it in the class intializer section.

When we have constructor with one parameter, an implicit creation is
also created. That means that we can use an object of the type of the
parameter that the single-parameter constructor expects, and it will
get automatically "constructed" for us, e.g. we can use a string
instead of an object constructed with the 1-string constructor.

We can disable implicit conversions by using the keyword =explicit= in
our constructors.

We can make a member associated with a class, rathen than instances of
the class by using the =static= keyword.

* Chapter 08: The IO library
[2017-12-31 Sun 00:08]

In the chapter, there are mentions that there exists the io functions
in the library prepended by a 'w' to indicate the use of wchar_t
instead of just char. However, I wanted to try a program to see if the
normal streams would break on reading input in spanish, but they
didn't, then I tried to paste an input in chenese but it didn't break
either, so far I don't know for what cases the =wchar_t= is really
necessary.

Because we can't copy the IO types, we cannot have a parameter or
return type that is one of the stream types, although we can use
references.

Streams have a function called =.tie= that, when called on another
stream, it ties them together, so that if the one is flushed the other
is flushed too. The library automatically ties cout to cin for us.

The only way to preserve the existing data in a file opened by an
ofstream is to specify /app/ or /in/ mode explicitly.

* Chapter 09: Containers
[2017-12-31 Sun 10:51]

Rules of thumb:

- Unless you have a reason not to, use =vector=.
- If you have lots of small elements and space matters don't use
  =list= or =forward_list=.
- If the program requires random access use =vector= and =deque=.
- If the program needs to insert or delete elements in the middle, use
  =list= or =forward_list=.
- If the program needs to insert at both ends, and not in middle, use
  =deque=.


It's a good idea to use operations common to both =vector= s and
=list= s, i.e. iterators, not subscripts, that way it is easy to
change the container type being used down the road.

The containers have, among their shared methods, a version of =begin=,
=end=, =cbegin= and =cend= that are prepended by an 'r', this denotes
that they return a 'reverse' iterator, capable of moving through
elements in a backwards fashion.

Ranges of iterators in c++ are left-inclusive intervals. The end
iterator is one past the last element of the container, and therefore
it is kind of wrong to call the iterators first and last, and not
begin and end.

There is a type =array= that pretty much gives us the functionality of
primitive arrays but with the interfaces of the library container
types.

I was introduced to two families of functions that the containers have
to introduce new elements into their collections: the family of
'insert' and the family of 'emplace'. The difference between what each
family does is that the members of the 'insert' family accept objects
of the type that the container accepts, and copies them to their
respective places. The emplace family take the constructor arguments
of the type they accept, construct the objects and then adds them,
basically saving us from having to construct objects ourselves.

I've learned that the containers also provide the member functions
=front= and =last=. This function return references to the first and
last element of a container (that's right, the references are returned
directly, not a pointer which we would need to dereference as is the
case with =begin=, =end= and the like). Furthermore, let's remember
that the =end= variants of member functions return a pointer to one
past the last element of a container, so dereferencing means nothing,
=last= gets us the last element appropiately.

For accessing elements, we also have the square bracket operator =[]=
and the =at= member function. They are different since the square
brackets can only take unsigned integers, and if a non-valid value is
provided, i.e. a value greater than or equal to the size of the
container, the result is undefined. The =at= member function, on the
other hand, can accept arguments that are not unsigned integer (which
will be useful for non sequential containers that utilize keys) and
also, if given an incorrect value, it raises a =std::out_of_range=
exception rather than continuing silently with undefined behaviour.

It is a good idea to minimize the part of a program where a given
iterator is used, to minimize the probability that our operations will
render it invalid. Loops that add or remove elements from a container
should usually ensure that the iterators are refreshed after the
affecting operations. In particular, we should avoid storing the
interator returned from the =end= family of functions in order to save
computation, it is much more safer to actually call the corresponding
=end= function each time around.

The difference between a vector's capacity and its size is that its
size denots the number of elements it already contains. The capacity
denotes the number of elements it can contain before triggering a
reallocation.

The container =forward_list= has a different kind of member functions
for adding and removing elements. These functions are postfixed by
=_after=, i.e. =insert_after()=. The reason for this is that they take
a pointer and actually insert (or erase) the element after it. The
reason for this is that =forward_list= is a singly linked list, and in
these kinds of lists, an element doesn't have a pointer to the
previous elements that points to it, so it is not easy to get a hold
of its predecessor in order to change its next reference
accordingly. Also, there is the posibility to obtain a pointer to one
before the first element through =before_begin= and its derivations.

I've learned that the functions that convert a string into a numeric
type, i.e. =stof()=, can work even if the string contains non-numeric
characters, but only when these appear after some numeric ones. In
other words, if the string begins with non-numeric characters the
conversion will fail, but if the non numeric characters trail, they
will just be ignored.

When writing the Date program (exercise 9.51) I realized I had some
misunderstandings about a couple of concepts. Here is what I learned:

- When using =std::array=, you indicate the size as a second argument
  to the template angle brackest, not in square brackets after the
  variable name as you would with a primitive array.
- When using static class members, this cannot be defined inside the
  class. They also can't be defined in a function (I tried to define
  them in main). It seems to me that they must be defined on the outer
  (global) scope.
- If you intend to call another constructor from a class constructor,
  you must do so in the constructor intializer list, if you do it in
  the body of the constructor all you do is create an anonymous
  object, the member functions of the object that called the original
  constructor do not get involved.
  
* Chapter 10: Algorithms
[2018-01-01 Mon 19:10]

The generic algorithms do not themselves execute container
operations. They operate solely in terms of iterators and iterator
operations.

There are over 100+ algorithms in the standard library.

A few algorithms:

- find
- count
- accumulate
- equal
- fill
- replace
- replace_copy
- stable_sort
- partition
- find_if
- for_each
- transform
  


I learned that the =std::accumulate= function comes in the =numeric=
header, I was including =algorithm= and spent a good 15 minutes trying
to figure out why the compilation was failing.

There is a special kind of iterator called =insert iterator=, this iterators,
when assigned, rather than changing the contents of the object they point
to, they call some container function that inserts new elements. For example,
the =back_inserter= iterator, when assigned, calls =push_back= under the hood.

In c++, callables are objects that can be "invoked", i.e. putting
parenthesis after them with, optionally, some arguments. It turns out
that not only are functions and function pointers callables, but
classes that overload the function-call operator and lambdas
(anonymous function) are too.

A lambda looks like this:

#+BEGIN_EXAMPLE
[capture list] (parameter list) -> return type { function body }
#+END_EXAMPLE

We can omit the parameters or return type from a lambda. But must
always put the capture list (if empty just put the brackets). Also,
lambdas may not have defaults for their parameters.

It is possible to capture variables from the enclosing scope in a
lambda by reference just like by value. In addition, we can use the
shortcuts =[&]= and =[=]= to include all the variables in the
enclosing scope by reference and by value, respectively, without
having to type each one.

It is important to note also that, when capture by value is employed
in a lambda, the copies are done at the time the lambda is defined,
not when it is invoked.

We can also return a lambda from a function. The function might
directly return a callable object or the function might return an
object of a class that has a callable object as a data member. If the
function returns a lambda, then—for the same reasons that a function
must not return a reference to a local variable—that lambda must not
contain reference captures.

It is obvious that lambdas should be used for short functions that are
not going to be called in many places. Conversely, functions should be
used for code that is repeated in many places, or that is too
long. However, there is a place in which lambdas shine, and that is in
the capturing of the enclosing scope variables. A function cannot do
that, and even if we can add parameters by reference to a function,
this might prohibit us from using it as an argument to another
function that does not expects its callables to have extra
parameters. To overcome this, the =functional= header provides the
=bind= function; it takes a callable object and generates a new
callable object that "adapts" the parameter list of the original.

#+BEGIN_EXAMPLE
auto newCallable = bind(callable, arg_list);
#+END_EXAMPLE

The arg_list can have names of the form "_name" to indicate that it is
a place holder, i.e., something that should not be adapted and remain
a parameter on the callable that will be created. Note that the
placeholders are in the =placeholders= namespace inside of the =std=
namespace so it makes sense to use them all with something like

#+BEGIN_EXAMPLE
using namespace std::placeholders;
#+END_EXAMPLE

=bind= can also be used to rearrange or reoder the parameters of a
callable.

Once again, binds parameters are not references, if we want to pass
something as a reference we will need to use the =ref= function,
example:

#+BEGIN_EXAMPLE
for_each(words.begin(), words.end(), bind(print, ref(os), _1, ' '));
#+END_EXAMPLE

We can also create iterators on =istream= and =ostream=, if we default
initialize the iterator, we obtain one that we can use as the
off-the-end value.

The =ostream= iterators are used to assign to them, where the ===
operator calls the =<<= operator under the hood.

The book points out that we can sort a container by passing a pair of
reverse iterators.

Reverse iterators have a =base= member function that returns an
iterator that points at the equivalent element, but that moves forward (or
normally). This is useful, for example, if after obtaining an iterator
from =find= with reverse iterator arguments we want to create a
string, we cannot pass the reverse iterator, it needs to be a normal
one.

Iterator Categories
| Input Iterator       | Read, but not write. single-pass increment only.     |
| Output Iterator      | Write, but not read. single-pass increment only.     |
| Forward Iterator     | Read and write; multi-pass, increment only           |
| Bidirection Iterator | Read and write; multi-pass, incr and decr            |
| Random  access       | Read and write; multi-pass, full iterator arithmetic |

* Chapter 11: Associative containers
[2018-01-03 Wed 08:31]

The standard library provides 8 associative containers. Each of these
containers is a =set= or a =map=, requires unique keys or allows
multiple keys and stores the elements in order or not $2^3 = 8$.

I was making the mistake of thinking that the =first= and =second=
memebers of the maps where functions that returned the corresponding
objects, rather, they are references to the objects themselves.

For the maps, what’s important is that a type that defines a <
operator that “behaves normally” can be used as a key. That is if it
upholds the properites of symmetry and transitivity.

If we don't have the operator set up for the compatibility mentioned
above we can pass a function that receives the key elements and
compares them. This function is passed as an argument to the
constructor.

The associative containers define the types =key_type=, =value_type=
and =mapped_type=. Note that for maps, =value_type= is actually the
pair and =mapped_type= is the type of the pair's second member.

I was making the mistake of thinking that in the multi maps, when you
iterated through them, you got a pair of the key and an iterator that
would take you through all the values mapped to that key. I was wrong.
It turns out you get a key-value pair like you do with normal
containers, is just that you may get key-value pairs with the same
keys.

Unlike vector or string, the type returned by the map subscript
operator differs from the type obtained by dereferencing a map
iterator.

We are guaranteed that iterating across a multimap or multiset returns
all the elements with a given key in sequence.

Unordered associative containers have the same api as their ordered
counterparts. In addition, they also have methods that allow us to
manage the buckets directly (yes we are talking about the buckets
where elements are stored, and which can store more than one element
in case of a hash collision). These members let us inquire about the
state of the container and force the container to reorganize itself as
needed.

- =c.bucket_count()=
- =c.max_bucket_count()=
- =c.bucket_size(n)=
- =c.bucket(element)=
- =c.load_factor()=
- =c.max_load_factor()=
- =c.rehash(n)=
  
* Chapter 12: Dynamic memory
[2018-01-05 Fri 11:33]

Smart pointers ensure that the objects to which they point are
automatically freed when it is appropriate to do so. Their whole
reason d'etre is to mitigate the common bugs that are introduced by
improper management of memory.

In adition to static or stack memory, every program also has a pool of
memory that it can use. This memory is called the =free store= or
=heap=.

The keyword =new= allocates, and optionally intializes, an object in
dynamic memory and returns a pointer to that object. Similarly,
=delete= takes a pointer to a dynamic object, destroys the object and
frees the associated memory.

The smart pointers are defeined in the =memory= header.

Analogous to its constructors, each class has a destructor. Just as a
constructor controls initialization, the destructor controls what
happens when objects of that class type are destroyed.

Programs tend to use dynamic memory for one of three purposes:

1. They don’t know how many objects they’ll need
2. They don’t know the precise type of the objects they need
3. They want to share data between several objects

   

Remember that copying a shared_ptr increments its reference count.

If we do not initialize a smart pointer, it is initialized as a null
pointer. We can also initialize a smart pointer from a pointer
returned by new.

Shared pointers can only coordinate between themselves if they are
copies!  Even if they are initialized from the same pointer, they wont
be related.  Always copy. Not even initializing from another shared
pointers =get()= member, which returns a plain pointer, will work.

When a function exits, whether through normal processing or due to
an exception, all the local objects are destroyed.

By default, when a shared_ptr is destroyed, it executes delete on the
pointer it holds. However, if we were to use, for example, a c
library, of course the code there won't have destructors, but rather
functions that must be called to free resources. This is no problem as
actually we can create shared pointers and give them a second argument
that is callable with our own destruction code. Yes, we must be aware
of how to destroy the elements, but we won't need to keep track of
when to destroy them.

To use smart pointers correctly we want to adhere to these principles:

- Don’t use the same built-in pointer value to initialize (or reset)
  more than one smart pointer.
- Don’t delete the pointer returned from get().
- Don’t use get() to initialize or reset another smart pointer.
- If you use a pointer returned by get(), remember that the pointer will
  become invalid when the last corresponding smart pointer goes away.
- If you use a smart pointer to manage a resource other than memory
  allocated by new, remember to pass a deleter callable.
  


Unique pointer has a =release()= member that returns a pointer to the
thing, and sets the unique pointer to =nullptr=, avoiding the
destruction of the object. Also a =reset()= member.

A weak_ptr is a smart pointer that does not control the lifetime of
the object to which it points. Instead, a weak_ptr points to an object
that is managed by a shared_ptr.

* Chapter 13: Copy control
[2018-01-06 Sat 16:49]

What we mean by copy control, are the five special member functions:
copy contructor, copy-assignment constructor, move constructor,
move-assignment constructor and destructor.

A constructor is the copy constructor if its first parameter is a
reference to the class type and any additional parameters have default
values. The copy constructor should not usually be explicit.

Copy intialization occurs when:

- When we define variables using an equal sign (===)
- Pass an object as an argument to a parameter of nonreference type
- Return an object from a function that has a nonreference return type
- Brace initialize the elements in an array or the members of an
  aggregate class

  

The requirement that the copy constructor takes its class parameter as
a reference, stems from the fact that copy initialization is used
whenever we have a nonreference parameter in a callable. If the copy
constructor took a nonreference parameter, it would need to copy it
first, which would trigger an infinite loop of calls to the copy
constructor.

Overloaded operators are functions that have the name operator
followed by the symbol for the operator being defined. Hence, the
assignment operator is a function named operator=. Aside from that,
they look like any other kind of function.

Assignment operators usually return a reference to their left-hand
operand.

I was confused about when the copy assignment constructor was used,
since the statement =SomeClass some_name = some_instance= uses the
copy constructor, not the copy assignment. It turns out that the copy
assignment constructor is used when we redefine a variable,
i.e. =some_name = some_instance=, note that this variable must have
been declared earlier and therefore we do not include the class name
in the assignment statement.

The destructor is a member function with the name of the class
prefixed by a tilde (~). It has no return value and takes no
parameters.

It is important to realize that the destructor body does not directly
destroy the members themselves. Members are destroyed as part of the
implicit destruction phase that follows the destructor body. A
destructor body executes in addition to the memberwise destruction
that takes place as part of destroying an object.

One rule of thumb to use when you decide whether a class needs to
define its own versions of the copy-control members is to decide first
whether the class needs a destructor. This is because the default
version of the destructor will not delete pointer
members. Furtheremore, the default copy constructors will copy the
pointers directly, not create new pointers pointing to the same object
as the original pointer.

Consider a class that gives each object its own, unique serial
number. Such a class would need a copy constructor to generate a new,
distinct serial number for the object being created

Rule of thumb: If a class needs a copy constructor, it almost surely
needs a copy-assignment operator

A deleted function is one that is declared but may not be used in any
other way. We indicate that we want to define a function as deleted by
following its parameter list with == delete=.

Classes that want to prevent copying should define their copy
constructor and copy-assignment operators using = delete rather than
making those members private.

Assignment operators must work correctly if an object is assigned to
itself. Be careful about deleting pointers.

A good pattern to use when you write an assignment operator is to
first copy the right-hand operand into a local temporary. After the
copy is done, it is safe to destroy the existing members of the
left-hand operand. Once the left- hand operand is destroyed, copy the
data from the temporary into the members of the left-hand operand.

It is in our best interest, specially if we intend to use a class in
algorithms that reorder elements to implement a =swap= method to
interchange two objects. This can bring about improved efficiency as
we can be smart about how we do it. For example, if our class only
have a string pointer member, then we should exchange the string
pointers, instead of creating new objects that are copies and
assigning them to their counterparts.

There is something about swap that we must be careful, in our own
implementations of swap functions we must be careful to use the
following pattern:

#+BEGIN_SRC cpp
void swap(Foo &lhs, Foo &rhs)
{
  using std::swap;
  swap(lhs.h, rhs.h); // uses the HasPtr version of swap
                      // swap other members of type Foo
}
#+END_SRC

This is because if classes define a =swap= member function, that is
more specialized and should be used instead of the =std::swap= generic
function. By using this pattern, if the class has defined its own
swap, it will win during method resoultion, otherwise, the generic
version will be used.

Classes that define swap often use swap to define their assignment
operator. These operators use a technique known as copy and swap. This
technique swaps the left- hand operand with a copy of the right-hand
operand.

The copy-assignment operator often does the same work as is needed in
the copy constructor and destructor. In such cases, the common work
should be put in private utility functions.

I've learned that a lambda can only be converted to a function pointer
if it does not capture.

The allocators have a construct and destruct memebers that can
actually make the elements for us (they also take, as their first
parameter, the pointer of where to put them).

TODO: Need to learn more about allocators uninitiallized_copy

Move constructors typically operate by “moving” resources from the
given object to the object being constructed. There also is a generic
=move= function in the =utility= header.

The library containers, string, and shared_ptr classes support move as
well as copy. The IO and unique_ptr classes can be moved but not
copied.

To support move operations, the new standard introduced a new kind of
reference, an rvalue reference. An rvalue reference is obtained by
using a double ampersand instead of a single one, i.e. =&&=.

Functions that return a nonreference type, along with the arithmetic,
relational, bitwise, and postfix increment/decrement operators, all
yield rvalues. We cannot bind an lvalue reference to these
expressions, but we can bind either an lvalue reference to const or an
rvalue reference to such expressions.

Rvalue references refer to objects that are about to be
destroyed. Hence, we can “steal” state from an object bound to an
rvalue reference.

Although we cannot directly bind an rvalue reference to an lvalue, we
can explicitly cast an lvalue to its corresponding rvalue reference
type. We can also obtain an rvalue reference bound to an lvalue by
calling a new library function named move, which is defined in the
utility header. The move function uses facilities that return an
rvalue reference to its given object.

Move constructors and move assignment operators that cannot throw
exceptions should be marked as =noexcept=.

A Moved-from Object Must Be Destructible

The move operations are not synthesized if they would otherwise be
defined as deleted.

If a class has a usable copy constructor and no move constructor,
objects will be “moved” by the copy constructor. Similarly for the
copy-assignment operator and move-assignment.

Overloaded functions that distinguish between moving and copying a
parameter typically have one version that takes a const T& and one
that takes a T&&.

We can put a reference qualifier =&= or =&&= at the end of our
function signatures, like =operator== to indicate that only lvalue or
rvalues can be used in a statement containing them. A function can be
both const and reference qualified. In such cases, the reference
qualifier must follow the const qualifier

If a member function has a reference qualifier, all the versions of
that member with the same parameter list must have reference
qualifiers.
* Chapter 14: Overloaded operations and conversions
[2018-01-15 Mon 11:54]

Operator overloading lets us define the meaning of an operator when
applied to operand(s) of a class type.

We can have overloaded operators that are member functions of a class
and that are not. In the case where they are not, the left operand is
bound to the left, or first, parameter and the right operand is bound
to the right, or second, parameter. In the case of overloaded
operators that are members of a class, the left operand is implicitly
bound to the =this= pointer.

An operator function must either be a member of a class or have at
least one parameter of class type, we cannot redefine operators for
the built-in or primitive types.

Ordinarily, we “call” an overloaded operator function indirectly by
using the operator on arguments of the appropriate type. However, we
can also call an overloaded operator function directly in the same way
that we call an ordinary function. We name the function,
e.g. =operator+(...= and pass an appropriate number of arguments of
the appropriate type.

Ordinarily, the comma, address-of, logical AND, and logical OR
operators should not be overloaded. Overloaded operators are treated
as function calls, and therefore, their precedense or executions
property differ from their standard behaviour.

Guidelines to decide whether an overloaded operator should be a member
or not:

- The assignment (=), subscript ([]), call (()), and member access
  arrow (->) operators must be defined as members.
- The compound-assignment operators ordinarily ought to be
  members. However, unlike assignment, they are not required to be
  members.
- Operators that change the state of their object or that are closely
  tied to their given type—such as increment, decrement, and
  dereference—usually should be members.
- Symmetric operators—those that might convert either operand, such as
  the arithmetic, equality, relational, and bitwise operators—usually
  should be defined as ordinary nonmember functions.



Input and output operators that conform to the conventions of the
iostream library must be ordinary nonmember functions. These operators
cannot be members of our own class. If they were, then the left-hand
operand would have to be an object of our class type


Ordinarily, if we have two objects, neither of which is less than the
other, then we expect that those objects are equal.

Assignment operators must, and ordinarily compound-assignment
operators should, be defined as members. These operators should return
a reference to the left-hand operand.

If a class has a subscript operator, it usually should define two
versions: one that returns a plain reference and the other that is a
const member and returns a reference to const.

Classes that define increment or decrement operators should define
both the prefix and postfix versions. These operators usually should
be defined as members.

To be consistent with the built-in operators, the postfix operators
should return the old (unincremented or undecremented) value. That
value is returned as a value, not a reference.
 
The overloaded arrow operator must return either a pointer to a class
type or an object of a class type that defines its own operator arrow.

Classes that overload the call operator allow objects of its type to
be used as if they were a function. Because such classes can also
store state, they can be more flexible than ordinary functions.

Function objects are most often used as arguments to the generic
algorithms. For example, we can use the library for_each algorithm (§
10.3.2, p. 391) and our PrintString class to print the contents of a
container:

Under the hood, when we write a lambda, the compiler actually makes an
anonymous class for us with the functional call operator overloaded.

We now know the many kinds of entities that act like functions (what
we call 'callables'), but each of these have different types. Say we
wanted to build a calculator program, and we wanted to use a map from
char or string to function to store the operations. Initially, we
might consider making the mapped type a function pointer, and this
would work for "normal" functions and pointers to functions, but would
not work, for example, with lambdas. To overcome this, the
=<functional>= header provides the template =function<>=
i.e. =function<int(int, int)>=, which makes it possible to have
objects store any of the different callable types, as long as they
share the same signature. It is important to note that we won't be
able to use overloaded functions this way, since there would be
ambiguity. In such cases we can wrap them in a lambda or assign them
to the appropiate function pointer first.

A conversion operator is a special kind of member function that
converts a value of a class type to a value of some other type. A
conversion function typically has the general form

A conversion function must be a member function, may not specify a
return type, and must have an empty parameter list. The function
usually should be const.

Usually, conversion operators cause more harm than good, with one
exception, conversions to =bool=. However, this must almost always be
declared as =explicit=.

Ordinarily, it is a bad idea to define classes with mutual conversions
or to define conversions to or from two arithmetic types.

When two user-defined conversions are used, the rank of the standard
conversion, if any, preceding or following the conversion function is
used to select the best match.

Needing to use a constructor or a cast to convert an argument in a
call to an overloaded function frequently is a sign of bad design.
* Chapter 15: Object-Oriented Programming
[2018-01-19 Fri 20:50]

OOP is based on three fundamental concepts:

- data abstraction
- inheritance
- dynamic binding
  


In C++, the superclasses of a derived class are denoted in the class
derivation list, after a colon in front of the class name. The
elements in the class derviation list may have an access specifier, if
=public= that would indicate that we can use objects of the derived
class as if they were their superclass type.

Derived classes must provide implementations for each virtual method
in the super class. A derived class may include the =virtual= keyword
or not, it is not required. The new standard lets a derived class
explicitly note that it intends a member function to override a
virtual that inherits, by specifying the keyword =override= after its
parameters.

Dynamic binding is sometimes known as run-time binding.

In C++, dynamic binding happens when a virtual function is called
through a reference (or a pointer) to a base class.

Classes used as the root of an inheritance hierarchy almost always
define a virtual destructor.

Derived classes frequently, but not always, override the virtual
functions that they inherit. If a derived class does not override a
virtual from its base, then, like any other member, the derived class
inherits the version defined in its base class.

The fact that a derived object contains subobjects for its base
classes is key to how inheritance works.

The base class is initialized first, and then the members of the
derived class are initialized in the order in which they are declared
in the class.

It is essential to understand that each class defines its own
interface. Interactions with an object of a class-type should use the
interface of that class, even if that object is the base-class part of
a derived object. As a result, derived-class constructors may not
directly initialize the members of its base class. The constructor
body of a derived constructor can assign values to its public or
protected base-class members. Although it can assign to those members,
it generally should not do so. Like any other user of the base class,
a derived class should respect the interface of its base class by
using a constructor to initialize its inherited members.

The base class initiatilization list should not be written in forward
declarations.

We can prevent a class from being extended by following its name with
the keyword =final=.

We can bind a pointer or reference to a base-class type to an object
of a type derived from that base class. For example, we can use a
Quote& to refer to a Bulk_quote object, and we can assign the address
of a Bulk_quote object to a Quote*

A function that is virtual in a base class is implicitly virtual in
its derived classes. When a derived class overrides a virtual, the
parameters in the base and derived classes must match exactly.

The =keyword= override is there to help us find bugs when we think we
are overriding a base membe function but in fact we are wrong, perhaps
because of different function parameters. Without the =override=
keyword, the overloaded version of the function is valid but not
related to the base class.

Virtual functions that have default arguments should use the same
argument values in the base and derived classes.

Using the =scope::= operator we can force to call the version of a
virtual method that corresponds to any class in the hierarchy.

A function is deemed =pure virtual= if it is followed by an == 0= in
its declaration. A class with a =pure virtual= function is considered
and abstract class, which defines an interface, and makes it
impossible to instantiate members of said class.

The accesibility specifier we use when declaring a class' superclasses
has nothing to do with the ability of the members of the subclass
to access the members of its superclass, access is gated by the
access specifiers of the members in the superclass declaration.
The specifier we use in the superclass list is there so that we say
whether users of the subclass or further subclasses can access
public or protected members.

In the absence of inheritance, we can think of a class as having two
different kinds of users: ordinary users and implementors. Ordinary
users write code that uses objects of the class type; such code can
access only the public (interface) members of the class. Implementors
write the code contained in the members and friends of the class. The
members and friends of the class can access both the public and
private (implementation) sections.  Under inheritance, there is a
third kind of user, namely, derived classes. A base class makes
protected those parts of its implementation that it is willing to let
its derived classes use. The protected members remain inaccessible to
ordinary user code; private members remain inaccessible to derived
classes and their friends.  Like any other class, a class that is used
as a base class makes its interface members public . A class that is
used as a base class may divide its implementation into those members
that are accessible to derived classes and those that remain
accessible only to the base class and its friends. An implementation
member should be protected if it provides an operation or data that a
derived class will need to use in its own implementation. Otherwise,
implementation members should be private.
 
Friendship is not inherited; each class controls access to its
members.

A derived class may provide a using declaration only for names it is
permitted to access. That is, if the derived class inherits with
=private= from a base class, but decides it wants a specific memeber
to be avilable to further derived classes, it would use a =using
Base::member= declaration in its protected section. If it wanted to
make a member that is public in the base class available to all users,
it owuld need to use a =using Base::member= declaration in its public
section (since the =private= inheritance would have made all inherited
members private by default).

A derived-class member with the same name as a member of the base
class hides direct use of the base-class member.

If a derived class wants to make all the overloaded versions available
through its type, then it must override all of them or none of them.

When a derived class defines a copy or move operation, that operation
is responsible for copying or moving the entire object, including
base-class members.

Because derived objects are “sliced down” when assigned to a base-type
object, containers and types related by inheritance do not mix well.

When we need a container that holds objects related by inheritance, we
typically define the container to hold pointers (preferably smart
pointers to the base class.

During an example of a =Basket= class that managed a collection of
=Quote=s, the authors use a multiset to store them. When they loop
over the items in a multset, rather than increase the pointer with the
increment unary operator they use =upper_bound=. The call to
=upper_bound= returns the iterator that refers to the element just
past the last one with the same key as in iter.

It is useful to define members that clone and move the object for
cases when we create other classes that operate on this objects, but
we don't want our users to concern themselves with having to create
shared pointers and the like. With these operations, the functions can
take a Base class parameter, and call the virtual clone member.

* My common mistakes
[2018-01-20 Sat 23:56]

** Attempting to assign variables in global scope
[2018-01-20 Sat 23:56]
In C++, you can only initialize variables in global, you can't assign
them there.

An example of me commiting this error was during exercise-15-20 where
I attempted to write the following:

#+BEGIN_SRC cpp
// Exercise 15.20, page 762
//
// Write code to test your answers to the previous two exercises.
//
// Exercise 15.5
//
// Given the classes from page 612 and page 613, and assuming each
// object has the type specified in the comments, determine which of
// these assignments are legal. Explain why those that are illegal
// aren’t
//
// Base *p = &d1; d1 has type Pub_Derv
// p = &d2; d2 has type Priv Derv
// p = &d3; d3 has type Prot_Derv
// p = &dd1; dd1 has type Der_from_Public
// p = &dd2; dd2 has type Der_from_Private
// p = &dd3; dd3 has type Der_from_Protected

class Base {
};

class Pub_Derv : public Base {
};

class Priv_Derv : private Base {
};

class Prot_Derv : protected Base {
};

class Derived_from_Public : public Pub_Derv {
};

class Derived_from_Private : public Priv_Derv {
};

class Derived_from_Protected : public Prot_Derv {
};


Pub_Derv d1;
Pub_Derv d2;
Pub_Derv d3;
Derived_from_Public dd1;
Derived_from_Private dd2;
Derived_from_Protected dd3;

p = &d2;
p = &d3;
p = &dd1;
// p = &dd2; // Cannot do this as the Base class part of the object is private
// p = &dd3; // Cannot do this because this is user code, not subclass code
#+END_SRC
 
When I should have made those assignments inside a function like
=main=.

